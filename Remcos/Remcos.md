# Remcos

| Malware Name | File Type | SHA256 |
| --- | ----------- | ----------- |
| Remcos | x32 exe (.NET) | 5eb996275b36c1e8c1d3daa71e6469507a29401c77f2b1fd91e4d354ccde9860 |

## Analysis process

This writeup starts with a suspicious executable that was sent via mail.

We can see that most part of the PE is packed (entropy ~ 8 -> High entropy indicates on encrypted / compressed data):

![i](/Remcos/img/1.PNG)   

The PE is .NET so we'll check it out in Dnspy:

![i](/Remcos/img/2.PNG)

As usual, we'll watch it under Procmon. this is the interesting process tree:

![i](/Remcos/img/3.PNG)

We can see that:
 - The file creates scheduled task for persistence
 - The file writes a vbs script to `\AppData\Local\Temp\` and runs it
 - The vbs script copies the malware to `\AppData\Roaming\remcos\` (Nice spoiler, thank you malware author :kissing_heart:), and executes it from there.

The Script content:

![i](/Remcos/img/4.PNG)

As we can see, after the copy & execute, the vbs script deletes itself (and is written back next execution).

In this analysis i took the "quick and dirty" approach, so i in order to unpack the file, i let it run for about a minute or two, and then dumped it using Pe-Sieve (i added the /data argument, because this is .NET executable):

![i](/Remcos/img/5.PNG)

And Vwalla:

![i](/Remcos/img/6.PNG)

We've got our unpacked version with nice icon:

![i](/Remcos/img/7.PNG)

And it isn't packed:

![i](/Remcos/img/8.PNG)

The file is a native PE file (i.e. written in C\C++, unlike the loader which was written in .NET), and it's importing a lot of interesting libraries: 

![i](/Remcos/img/9.PNG)

Observing the strings we find very interesting finds:

Indeed the malware is Remcos PRO 2.7.2:

<img src="/Remcos/img/10.PNG" width=40% height=40%>

Keylogger capabilities:

<img src="/Remcos/img/11.PNG" width=45% height=45%>

Browser stealing capabilities:

<img src="/Remcos/img/12.PNG" width=65% height=65%>

Exfilitration and Infilitration capabilities:

<img src="/Remcos/img/13.PNG" width=50% height=50%>

The malware contains a setting resource which looks encrypted:

![i](/Remcos/img/14.PNG)

So we will try to watch it decrypted in memory. here we can see the file loads it:

![i](/Remcos/img/15.PNG)

And after some math we see the settings in clear text:

![i](/Remcos/img/16.PNG)

> c2 Server: 185.244.26.209

We can see some more juicy stuff, like Mutex string, execution path, logs path and encryption keys.

After some Googling about Remcos, seems like it is total legal software which has a very detailed [site](https://breakingsecurity.net/remcos/).
This is how the panel from the attacker side looks like:

![i](/Remcos/img/18.PNG)

A lot of nice and evil capabilities :smirk:.


## Bonus

After watching [this](https://www.youtube.com/watch?v=CYnzzJ8f3Ts&t=573s), i learned how Remcos encrypts his config, so i wrote a little script that retrieves a Remcos encrypted SETTINGS file, and decrypt it:

```
from os import path
from sys import argv
from Crypto.Cipher import ARC4
from string import printable
import colorama


def print_help():
    print("[-] Usage: {} <settings-file>".format(argv[0]))
    exit(1)


def hexdump(src, length=16, sep='.'):
    FILTER = ''.join([(len(repr(chr(x))) == 3) and chr(x) or sep for x in range(256)])
    lines = []
    for c in range(0, len(src), length):
        chars = src[c: c + length]
        hex_ = ' '.join(['{:02x}'.format(x) for x in chars])
        if len(hex_) > 24:
            hex_ = '{} {}'.format(hex_[:24], hex_[24:])
        printable = ''.join(['{}'.format((x <= 127 and FILTER[x]) or sep) for x in chars])
        lines.append('{0:08x}  {1:{2}s} |{3:{4}s}|'.format(c, hex_, length * 3, printable, length))
    return '\n'.join(lines)


def main():
    if len(argv) != 2 or not (path.isfile(argv[1])):
        print_help()
    with open(argv[1], "rb") as settings_file:
        settings_data = settings_file.read()

    # first byte in settings = key length
    key_length = settings_data[0]
    # then the key
    key = settings_data[1:key_length + 1]
    # then the encrypted data
    encrypted_data = settings_data[(key_length + 1):]

    # create rc4 object and decrypt
    rc4 = ARC4.new(key)
    decrypted = rc4.decrypt(encrypted_data)

    colorama.init(autoreset=True)

    # print hexdump
    print(colorama.Fore.LIGHTGREEN_EX + "\n###### Hexdump ######\n")
    print(hexdump(decrypted))
    print("\n")

    # print values in settings
    print(colorama.Fore.LIGHTGREEN_EX + "###### Values ######\n")
    printable_data = ""
    for byte in bytearray(decrypted):
        if chr(byte) in printable:
            printable_data += chr(byte)
    splited_data = printable_data.split("|")
    for value in splited_data:
        if len(value) > 0:
            print("[#] {}".format(value))
    print("\n")

main()

```
![i](/Remcos/img/17.PNG)







